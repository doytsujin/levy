# Sums and products are (awkwardly) introduced into Levy by the datatype 
# mechanism; polymorphism would make this much less awkward. Here we see an 
# encoding of `int + bool` and `int * bool`. 

data IAmAnInt: int -o intorbool
   | IAmABool: bool -o intorbool ;;

let v1 = IAmAnInt 4 ;;
let v2 = IAmABool false ;;

data Pair: int -o bool -o intandbool ;;

let v3 = Pair 12 true ;;



# Datatype declarations are most useful for their introduciton of inductive
# datatypes, like lists of integers or trees containing integers. 

data Nil: list
   | Cons: int -o list -o list ;;

data Emp: tree
   | Node: tree -o int -o tree -o tree ;;

let v4 = Node (Node Emp 3 Emp) 5 (Node Emp 7 (Node Emp 9 Emp)) ;;
let nil = thunk (fun x: list -> 
  match x with 
    | Nil -> return true
    | y -> return false) ;;

force nil Nil ;;
force nil (Cons 4 Nil) ;;

# The syntax we have chosen lets us define mutual recursive datatypes in a
# simple way, as we can see from the following definition of even/odd unary
# natural numbers. A lack of mutually recursive functions in Levy means that
# this isn't terribly useful, but there you go.

data Z: even
   | EO: even -o odd
   | OE: odd -o even ;;

let four = OE (EO (OE (EO Z))) ;;

# At the end of a datatype declaration the type is closed; it would be an error
# to have a subsequent declaration like `data One: even`

