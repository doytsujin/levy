# Examples from Huet, G. "Functional Perl: The Zipper." J. Functional 
# Programming 7(5): 549-554, September 1997.

data A: item
   | B: item
   | C: item
   | D: item
   | Times: item
   | Plus: item ;;

data Item: item -o tree
   | Section: list -o tree
   | Nil: list
   | Cons: tree -o list -o list ;;

# "a * b"
let ex1left = 
  Section 
   (Cons (Item A) 
    (Cons (Item Times) 
     (Cons (Item B) Nil))) ;;

# "c * d"
let ex1right = 
  Section 
   (Cons (Item A) 
    (Cons (Item Times) 
     (Cons (Item B) Nil))) ;;

# "a * b + c * d"
let ex1 = Section (Cons ex1left (Cons (Item Plus) (Cons ex1right Nil))) ;;

# The lack of polymorphic lists works as a bit of a hairshirt here, as we see 
# that the lists in the zipper structures are a bit different, and we want one 
# that falls off to the left and another that falls off to the right. 

data Top: path
   | Node: list -o path -o list -o path ;;

# We suggestively switch the ordering of components in a location 

data Loc: path -o tree -o location ;;

# The location of the second "*"
let ex2 = 
  Loc 
   (Node
     (Cons (Item C) Nil)
     (Node 
       (Cons (Item Plus) (Cons ex1left Nil))
       Top 
       Nil)
     (Cons (Item D) Nil))
   (Item Times) ;;
          

# Navigation primitives in trees

let revappend = thunk rec revappend : list -> list -> F list is 
  fun xs : list ->
  fun ys : list -> 
    match xs with
      | Nil -> return ys
      | Cons x xs -> force revappend xs (Cons x ys)

let go_left = thunk fun loc : location -> 
  match loc with 
    | Loc path tree -> 
       (match path with
          | Node left up right ->
             (match left with 
                | Cons lsibling left -> 
                   (return Loc (Node left up (Cons tree right)) lsibling))) ;;

let go_right = thunk fun loc : location -> 
  match loc with 
    | Loc path tree -> 
       (match path with
          | Node left up right ->
             (match right with 
                | Cons rsibling right -> 
                   (return Loc (Node (Cons tree left) up  right) rsibling))) ;;

let go_up = thunk fun loc : location -> 
  match loc with
    | Loc path tree ->
       (match path with
          | Node left up right ->
              force revappend left (Cons tree right) to trees in 
              return Loc up (Section trees)) ;; 

let go_down = thunk fun loc : location ->
  match loc with
    | Loc path tree ->
       (match tree with
          | Section trees -> 
             (match trees with 
                | Cons t1 trees -> 
                    return Loc (Node Nil path trees) t1)) ;;