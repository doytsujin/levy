# Examples from Huet, G. "Functional Perl: The Zipper." J. Functional 
# Programming 7(5): 549-554, September 1997.

data A: item
   | B: item
   | C: item
   | D: item
   | Times: item
   | Plus: item ;;

data Item: item -o tree
   | Section: list -o tree
   | Nil: list
   | Cons: tree -o list -o list ;;

# "a * b"
val ex1left = 
  Section 
   (Cons (Item A) 
    (Cons (Item Times) 
     (Cons (Item B) Nil))) ;;

# "c * d"
val ex1right = 
  Section 
   (Cons (Item A) 
    (Cons (Item Times) 
     (Cons (Item B) Nil))) ;;

# "a * b + c * d"
val ex1 = Section (Cons ex1left (Cons (Item Plus) (Cons ex1right Nil))) ;;

# Zippers and locations
# We suggestively switch the ordering of components in a location 

data Top: path
   | Node: list -o path -o list -o path ;;

data Loc: path -o tree -o location ;;

# The location of the second "*"
val ex2 = 
  Loc 
   (Node
     (Cons (Item C) Nil)
     (Node 
       (Cons (Item Plus) (Cons ex1left Nil))
       Top 
       Nil)
     (Cons (Item D) Nil))
   (Item Times) ;;
          

# Utility fuction

val revappend = thunk rec revappend : list -> list -> F list is 
  fun xs : list ->
  fun ys : list -> 
    match xs with
      | Nil -> return ys
      | Cons x xs -> force revappend xs (Cons x ys) ;;


# Safe navagation primitives in trees
data None: option
   | Some: path -o tree -o option ;;

val safe_left = thunk fun loc : location ->
  let (Loc path tree) be loc in 
  (match path with 
  | Top -> return None
  | Node left up right -> 
      (match left with 
      | Nil -> return None 
      | Cons lsibling left -> 
          return Some
            (Node left up (Cons tree right))
            lsibling)) ;;

val safe_right = thunk fun loc : location ->
  let (Loc path tree) be loc in
  (match path with 
  | Top -> return None
  | Node left up right -> 
      (match right with 
      | Nil -> return None 
      | Cons rsibling right -> 
          return Some
            (Node (Cons tree left) up right) 
            rsibling)) ;;

val safe_up = thunk fun loc : location ->
  let (Loc path tree) be loc in
  (match path with
  | Top -> return None
  | Node left up right -> 
      force revappend left (Cons tree right) to trees in
      return Some up (Section trees)) ;; 
  
val safe_down = thunk fun loc : location -> 
  let (Loc path tree) be loc in 
  (match tree with
  | Item _ -> return None
  | Section trees -> 
      (match trees with
      | Nil -> return None
      | Cons child trees -> 
          return Some 
            (Node Nil path trees)
            child)) ;; 


# Unsafe navigation primitives in trees

val go_left = thunk fun loc : location -> 
  let (Loc path tree) be loc in
  let (Node left up right) be path in
  let (Cons lsibling left) be left in
  return Loc (Node left up (Cons tree right)) lsibling ;;

val go_right = thunk fun loc : location ->
  let (Loc path tree) be loc in
  let (Node left up right) be path in
  let (Cons rsibling right) be right in
  return Loc (Node (Cons tree left) up right) rsibling ;;

val go_up = thunk fun loc : location -> 
  let (Loc path tree) be loc in
  let (Node left up right) be path in 
  force revappend left (Cons tree right) to trees in 
  return Loc up (Section trees) ;; 

val go_down = thunk fun loc : location ->
  let (Loc path tree) be loc in 
  let (Section trees) be tree in
  let (Cons child trees) be trees in 
  return Loc (Node Nil path trees) child ;;
