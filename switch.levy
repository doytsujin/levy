# This example file demonstrates match statements

let x = 5 in return (x + 9) ;;

# really just parses as

match 5 with 
  | x -> return (x + 9) ;;

# we also desugar if statements to match statements to 

if 5 < 4 then return 4 else return 5 ;; 

match 5 < 4 with
  | true -> return 4
  | false -> return 5 ;;

# but we also don't do exahustiveness checking currently, so the following
# will raise an error at runtime.
# match 5 < 4 with | true -> return 4 ;; 

# By adding match statements, we get the equivalent of "switch" in c:

let f = thunk (fun x: int ->
  match x with
    | 1 -> return 4
    | 2 -> return 3
    | 3 -> return 2
    | 4 -> return 1
    | 5 -> return 0
    | y -> return (x + y)) ;;

(force f) 1 ;;
(force f) 3 ;;
(force f) 5 ;;
(force f) 7 ;;

# We can also use datatype declarations to define enumerations. The following 
# declaration defines `Red`, `Blue`, `Yellow`, and `Green` as constructors of 
# type `color`.

data Red: color
   | Blue: color
   | Yellow: color
   | Green: color ;;

Red ;;
let colorcode = thunk (fun x: color -> 
  match x with
   | Red -> return 0
   | Blue -> return 1
   | Green -> return 2
   | Yellow -> return 3) ;;

(force colorcode) Red ;;
(force colorcode) Green ;; 

# The uppercase-is-for-constructors, lowercase-is-for-type-and-variables 
# distinction enforced by OCaml is used in Levy. Booleans are a special case:
# it is completely consistent to think of Boolean values as being defined by
# this enumeration, even though `true` and `false` are lowercase, not 
# uppercase.

# data true: bool
#    | false: bool
