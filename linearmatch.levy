# Demonstration of linear matching

data Nil: list
   | Cons: int -o list -o list ;;


# Discard the list up to the point where the int-holding hole was
val run = thunk rec run: (int -o list) -> F list is
  fun x: (int -o list) ->
    match x with
      | [hole: int] Cons hole l -> return l 
      | [hole: int] Cons i (dx hole) -> force run dx ;; 

force run ([hole: int] Cons hole Nil) ;; 
force run ([hole: int] Cons hole (Cons 3 (Cons 4 (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons hole (Cons 4 (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons hole (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons 4 (Cons hole (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons 4 (Cons 5 (Cons hole Nil))))) ;; 


# Demonstrates how coverage checking understands the difference between a list
# containing bools and a tree containing ints

data Bnil: blist
   | Bcons: bool -o blist -o blist ;;

data Pair: blist -o list -o pair ;;

val casebool = thunk fun x: (bool -o pair) ->
  match x with 
    | [hole: bool] Pair (blist hole) list -> return 0 ;;

val caseint = thunk fun x: (int -o pair) ->
  match x with 
    | [hole: int] Pair blist (list hole) -> return 0 ;;


# Demonstrates how coverage checking understands that different types can give
# rise to different inside patterns:

data Leaf: int -o tree
   | Node: int -o tree -o tree -o tree ;;

data Pair': list -o tree -o pair' ;;

val caseints = thunk fun x: (int -o pair') ->
  match x with
    | [hole: int] f (Cons hole xs) -> return 0 
    | [hole: int] f (Leaf hole) -> return 1 
    | [hole: int] f (Node hole t1 t2) -> return 2 ;;

data Z: even
   | EO: even -o odd
   | OE: odd -o even ;;

val eo1 = thunk fun x: (even -o odd) ->
  match x with
    | [hole: even] EO (f hole) -> return f ;; 

val eo2 = thunk fun x: (even -o odd) ->
  match x with
    | [hole: even] f (EO hole) -> return f ;; 

val oe = thunk fun x: (odd -o odd) ->
  match x with
    | [hole: odd] hole -> return [hole: even] (EO hole)
    | [hole: odd] f (OE hole) -> return f ;; 

val casetree = thunk fun x: (tree -o tree) ->
  match x with
    | [hole: tree] f (Node i t1 hole) -> return false 
    | [hole: tree] hole -> return false 
    | [hole: tree] f (Node i hole t1) -> return false ;;


# Matching lets us duplicate lists

data LinPair: (list -o list) -o (list -o list) -o linpair ;; 

val dup = thunk rec dup: (list -o list) -> F linpair is
  fun dxs: (list -o list) ->
    match dxs with 
      | [hole: list] hole -> 
          return LinPair 
            ([hole: list] hole)
            ([hole: list] hole)
      | [hole: list] Cons i (dxs' hole) ->
          force dup dxs' to pair in
          let (LinPair dxs1 dxs2) be pair in
          return LinPair
            ([hole: list] Cons i (dxs1 hole))
            ([hole: list] Cons i (dxs2 hole)) ;;

comp pair = force dup ([hole: list] Cons 2 (Cons 3 (Cons 4 (Cons 5 hole)))) ;;
comp dxs1 = let (LinPair dxs1 _) be pair in return dxs1 ;;
comp dxs2 = let (LinPair _ dxs2) be pair in return dxs2 ;;
dxs1 (Cons 100 Nil) ;;
dxs2 (Cons 200 Nil) ;;

