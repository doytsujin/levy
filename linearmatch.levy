# Demonstration of linear matching

data Nil: list
   | Cons: int -o list -o list ;;


# Discard the list up to the point where the int-holding hole was
val run = thunk rec run: (int -o list) -> F list is fun x: (int -o list) ->
  match x with
    | [hole: int] Cons hole l -> return l 
    | [hole: int] Cons i (dx hole) -> force run dx ;; 

force run ([hole: int] Cons hole Nil) ;; 
force run ([hole: int] Cons hole (Cons 3 (Cons 4 (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons hole (Cons 4 (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons hole (Cons 5 (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons 4 (Cons hole (Cons 6 Nil))))) ;; 
force run ([hole: int] Cons 2 (Cons 3 (Cons 4 (Cons 5 (Cons hole Nil))))) ;; 


# Demonstrates how coverage checking understands the difference between a list
# containing bools and a tree containing ints

data Bnil: blist
   | Bcons: bool -o blist -o blist ;;

data Pair: blist -o list -o pair ;;

val casebool = thunk fun x: (bool -o pair) ->
  match x with 
    | [hole: bool] Pair (blist hole) list -> return 0 ;;

val caseint = thunk fun x: (int -o pair) ->
  match x with 
    | [hole: int] Pair blist (list hole) -> return 0 ;;


# Matching lets us duplicate lists

data LinPair: (list -o list) -o (list -o list) -o linpair ;; 

val dup = thunk rec dup: (list -o list) -> F linpair is
  fun dxs: (list -o list) ->
    match dxs with 
      | [hole: list] hole -> 
          return LinPair 
            ([hole: list] hole)
            ([hole: list] hole)
      | [hole: list] Cons i (dxs' hole) ->
          force dup dxs' to pair in
          let (LinPair dxs1 dxs2) be pair in
          return LinPair
            ([hole: list] Cons i (dxs1 hole))
            ([hole: list] Cons i (dxs2 hole)) ;;

comp pair = force dup ([hole: list] Cons 2 (Cons 3 (Cons 4 (Cons 5 hole)))) ;;
comp dxs1 = let (LinPair dxs1 _) be pair in return dxs1 ;;
comp dxs2 = let (LinPair _ dxs2) be pair in return dxs2 ;;
dxs1 (Cons 100 Nil) ;;
dxs2 (Cons 200 Nil) ;;
