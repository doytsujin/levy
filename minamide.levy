# Examples from Yasuhiko Minamide's 1998 POPL paper "A Functional 
# Representation of Data Structures with a Hole."

# Figure 2: Using Hole Abstractions for Lists
# No polymorphic lists, blah.

data Nil: list
   | Cons: int -o list -o list ;;

data NilL: llist
   | ConsL: list -o llist -o llist ;; 

# Append

val append = thunk rec append: list -> list -> F list is 
  fun xs: list -> 
  fun ys: list -> 
    match xs with
      | Nil -> return ys
      | Cons x xs -> 
          force append xs ys to zs in
          return Cons x zs ;;

val hfun_append = thunk fun xs: list -> fun ys: list -> 
  let append_rec be thunk rec append_rec: list -> (list -o list) -> F list is
    fun xs: list -> 
    fun k: (list -o list) ->
      match xs with 
        | Nil -> return k ys
        | Cons x xs -> 
            force append_rec xs ([hole: list] k (Cons x hole))
  in 
    force append_rec xs ([hole: list] hole) ;; 

val xs = Cons 4 (Cons 5 (Cons 7 Nil)) ;;
val ys = Cons 19 (Cons 23 (Cons 41 Nil)) ;;
comp zs = force append xs ys ;;
comp zs = force hfun_append xs ys ;;

# Flatten

val flatten = thunk rec flatten: llist -> F list is
  fun xss: llist -> 
    match xss with
      | NilL -> return Nil
      | ConsL xs xss -> 
          force flatten xss to zs in
          force append xs zs ;;

val append' = thunk rec append': (list -o list) -> list -> F (list -o list) is
  fun k: list -o list ->
  fun xs: list ->
    match xs with
      | Nil -> return k
      | Cons x xs -> 
          force append' ([hole: list] k (Cons x hole)) xs ;;

val hfun_flatten = thunk fun xss: llist ->
  let flatten_rec be thunk rec flatten_rec: (list -o list) -> llist -> F list is
    fun k: (list -o list) ->
    fun xss: llist ->
      match xss with
        | NilL -> return k Nil
        | ConsL xs xss -> 
            force append' k xs to k' in
            force flatten_rec k' xss 
  in 
    force flatten_rec ([hole: list] hole) xss ;; 

val xss = ConsL xs (ConsL ys (ConsL zs (ConsL (Cons 0 Nil) NilL))) ;; 
comp ws = force flatten xss ;;
comp ws = force hfun_flatten xss ;; 


# Figure 3: Using Hole Abstractions for Trees
# No exceptions, so inserting an extant value just keeps the tree the same

data Lf: tree
   | Br: int -o tree -o tree -o tree ;; 

val binsert = thunk rec binsert: tree -> int -> F tree is
  fun t: tree ->
  fun y: int -> 
    match t with
      | Lf -> return Br y Lf Lf
      | Br x t1 t2 ->
          if y < x 
          then force binsert t1 y to t1' in return Br x t1' t2
          else if x < y 
          then force binsert t2 y to t2' in return Br x t1 t2'
          else return Br x t1 t2 ;; 

val hfun_binsert = thunk fun t: tree -> fun y: int ->
  let binsert' be thunk rec binsert': tree -> int -> (tree -o tree) -> F tree is
    fun t: tree ->
    fun y: int ->
    fun k: (tree -o tree) ->
      match t with
        | Lf -> return k (Br y Lf Lf) 
        | Br x t1 t2 -> 
            if y < x 
            then force binsert' t1 y ([hole: tree] k (Br x hole t2))
            else if x < y
            then force binsert' t2 y ([hole: tree] k (Br x t1 hole))
            else return k (Br x t1 t2) 
  in 
    force binsert' t y ([hole: tree] hole) ;;

val addone = thunk rec addone: tree -> F tree is
  fun t: tree ->
    match t with
      | Lf -> return Lf
      | Br x t1 t2 -> 
          force addone t1 to t1' in
          force addone t2 to t2' in
          return Br (x+1) t1' t2' ;;

# Woah. This one's crazy.

val hfun_addone = thunk rec hfun_addone: tree -> F tree is
  fun t: tree ->
    match t with
      | Lf -> return Lf
      | Br x t1 t2 ->
          let addone' be thunk rec addone': tree -> (tree -o tree) -> F tree is
            fun t: tree -> 
            fun k: tree -o tree ->
              match t with
                | Lf -> return k Lf
                | Br x t1 t2 ->  
                    force hfun_addone t1 to t1' in 
                    force addone' t2 ([hole: tree] Br (x+1) t1' hole)
          in
             force hfun_addone t1 to t1' in
             force addone' t2 ([hole: tree] Br (x+1) t1' hole) ;;
