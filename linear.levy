# Linear terms and linear application

data Nil: list
   | Cons: int -o list -o list ;;

# We can use linear terms to put *holes* in data. The syntax ([x: ty] ...),
# where x appears possibly under some term constructors, programmatially 
# represents the informal "imagine we have a list with one hole in it"

val z1 = [x: list] Cons 4 x ;; 
val z2 = [x: list] x ;;
val z3 = [x: list] Cons 5 (Cons 9 (Cons 12 x)) ;;
val z4 = [x: int] Cons 5 (Cons x (Cons 12 Nil)) ;; 

# Zippers are values, the application of a zipper to a value is also a value
# (you can think if it like "plus")

val l1 = z1 (Cons 4 Nil) ;;
val l2 = z2 (Cons 3 (z3 (Cons 4 (z4 19)))) ;;


# We can use zippers exactly like "difference lists" in logic programming: 
# tacking a cons cell into the hole and creating a new hole in the process.
# These can all be represented with local pointer manipulation, and so are
# effectively constant-time operations regardless of the length of the list.

val z5 = [x: list] x ;;
val z6 = [x: list] z5 (Cons 1 x) ;;
val z7 = [x: list] z6 (Cons 2 x) ;;
val z8 = [x: list] z7 (Cons 3 x) ;;
val z9 = [x: list] z8 (Cons 4 x) ;;
val zA = [x: list] Cons 0 (z9 x) ;;
val zB = [x: list] Cons (-1) (zA x) ;;
val zC = [x: list] Cons (-2) (zB x) ;;
val l3 = zC (Cons 5 Nil) ;;


# We can quickly (constant time) turn difference lists into lists, but turning 
# lists into difference lists is an O(n) operation that iterates over the list.

val makediff = thunk rec loop : list -> F (list -o list) is 
  fun xs : list ->
    match xs with
      | Nil -> return [hole: list] hole
      | Cons x xs -> 
        force loop xs to dxs in 
        return [hole: list] Cons x (dxs hole) ;; 

comp z = force makediff l1 ;;
z (Cons 100 Nil) ;; 
comp z = force makediff l2 ;;
z (Cons 200 Nil) ;; 

# The inside of a linear function must be a value, and the distinguished 
# variable must appear exactly once *within the term*.

data Pair: int -o int -o pair ;;

# This is fine:
[x: int] Pair x 4 ;;

# These would lead to syntax errors:
# [x: int] Pair 5 4 ;;
# [x: int] Pair 5 4 ;;
# [x: int] Pair x x ;;


# Zippers must be used with an affine discipline due to the fact that they
# are implemented using pointer-munging. I see work on affine type systems 
# as orthogonal, so re-using zippers causes a runtime error.

# This is displayed as a "used zipper" by the runtime
z5 ;; 

# Runtime failure, could be avoided with an affine type system
val fails = z5 Nil ;; 



