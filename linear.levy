# Linear terms and linear application

data Nil: list
   | Cons: int -o list -o list ;;

# We can use linear terms to put *holes* in data. The syntax ([x: ty] ...),
# where x appears possibly under some term constructors, programmatially 
# represents the informal "imagine we have a list with one hole in it"

let z1 = [x: list] Cons 4 x ;; 
let z2 = [x: list] x ;;
let z3 = [x: list] Cons 5 (Cons 9 (Cons 12 x)) ;;
let z4 = [x: int] Cons 5 (Cons x (Cons 12 Nil)) ;; 

# Zippers are values, the application of a zipper to a value is also a value
# (you can think if it like "plus")

let l1 = z1 (Cons 4 Nil) ;;
let l2 = z2 (Cons 3 (z3 (Cons 4 (z4 19)))) ;;


# We can use zippers exactly like "difference lists" in logic programming: 
# tacking a cons cell into the hole and creating a new hole in the process.
# These can all be represented with local pointer manipulation, and so are
# effectively constant-time operations regardless of the length of the list.

let z5 = [x: list] x ;;
let z6 = [x: list] z5 (Cons 1 x) ;;
let z7 = [x: list] z6 (Cons 2 x) ;;
let z8 = [x: list] z7 (Cons 3 x) ;;
let z9 = [x: list] z8 (Cons 4 x) ;;


# We can quickly (constant time) turn difference lists into lists, but turning 
# lists into difference lists is an O(n) operation that iterates over the list.

let makediff = thunk rec loop : (list -> F (list -o list)) is fun xs : list ->
  match xs with
    | Nil -> return [hole: list] hole
    | Cons x xs -> 
      force loop xs to dxs in 
      return [hole: list] Cons x (dxs hole) ;; 

force makediff l1 ;;
force makediff l2 ;;


# The inside of a linear function must be a value, and the distinguished 
# variable must appear exactly once *within the term*.

data Pair: U (int -> F int) -o int -o int -o pair ;;

# This is fine:
[x: int] Pair (thunk fun y: int -> return y + 5) x 4 ;;

# These would lead to syntax errors:
# [x: int] Pair (thunk fun y: int -> return y + 5) 5 4 ;; # Syntax error
# [x: int] Pair (thunk fun y: int -> return x + 5) 5 4 ;; # Syntax error
# [x: int] Pair (thunk fun y: int -> return x + 5) x 4 ;; # Type error
# [x: int] Pair (thunk fun y: int -> return x + 5) x x ;; # Syntax error


# Zippers must be used with an affine discipline due to the fact that they
# are implemented using pointer-munging. I see work on affine type systems 
# as orthogonal, but I do ensure

# This is displayed as a "used zipper" by the runtime
z5 ;; 

# Runtime failure, could be avoided with an affine type system
# let fails = z5 Nil ;; 



