# Queues with linearity and matching

# A queue here is a (q -o q), where the type "q" has one constructor. Notice
# that there are no inhabitants of type q, just inhabitants of (q -o q).

data QCons: int -o q -o q ;;

data None: option
   | Some: int -o (q -o q) -o option ;; 

val new = thunk return [x:q] x ;;

val push = thunk 
  fun i: int -> 
  fun queue: (q -o q) -> 
    return [x:q] queue (QCons i x) ;;

val pop = thunk fun queue: (q -o q) ->
  match queue with
    | [x:q] x -> return None
    | [x:q] QCons i (queue' x) -> return Some i queue' ;; 

val getq = thunk fun opt: option -> 
  let (Some _ q) be opt in return q ;; 

val isnone = thunk fun opt: option ->
  let None be opt in return [x: q] x ;; 

# Usage:

comp q = force new ;;
comp q = force push 3 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force isnone p ;;
comp q = force push 6 q ;;
comp q = force push 7 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force isnone p ;;
comp q = force push 8 q ;;
comp q = force push 9 q ;;
comp q = force push 12 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force push 4 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force push 5 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force push 6 q ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force getq p ;;
comp q = force pop q to p in force isnone p ;;
